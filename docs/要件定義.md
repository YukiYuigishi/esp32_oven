# 要件定義

更新日: 2026-01-20  
対象: ESP32-DevKit-C (Wrover-32E) / PlatformIO + Arduino framework  
目的: K型熱電対 + MAX31855 + SSR により、温度プロファイルに従ってヒーター温度を制御するファームウェアを実装する。

---

## 1. 目的

- K型熱電対で測定した温度にもとづき、SSRでヒーターを駆動し、ユーザーが入力した温度プロファイルを追従させる。
- ESP32上でWebサーバーを動作させ、Wi-Fi経由でUI（HTML/CSS/JS）を配信し、UIからAPIを呼び出して設定・運転・監視を行う。
- 制御方式はP制御をベースとし、SSRの特性に合わせて時間比例制御（Time Proportional Control）でON/OFFを行う。
- 物理スライドスイッチ（GPIO2, pull-up）で運転許可/禁止を切り替え、安全側（SSR OFF）を担保する。

---

## 2. スコープ

### 2.1 対象
- ESP32ファームウェア
  - 温度計測（MAX31855）
  - 温度プロファイル管理（作成/保存/読込/削除）
  - プロファイル運転（開始/停止）
  - P制御 + SSR駆動
  - Web UI配信（HTML/CSS/JS）
  - REST API提供
  - 設定値の永続化

### 2.2 非対象
- ヒーター、電源、筐体、配線の設計
- 高度な制御（PID等）の実装（拡張余地は残す）
- インターネット公開を前提とした堅牢な認証・暗号化（LAN内利用を前提に最小限とする）

---

## 3. 開発環境・前提

- 開発環境: PlatformIO
- フレームワーク: Arduino framework (ESP32)
- SPI: VSPIを使用
- ファイル配信/永続化: LittleFS（推奨）またはSPIFFS相当  
  - 本要件では「Flash上に静的ファイルと設定・プロファイルを保存可能」であることを要求する

---

## 4. ハードウェア要件

### 4.1 配線/ピン要件

| 機能 | デバイス | 接続 | ピン | 備考 |
|---|---|---:|---:|---|
| 温度計測 | MAX31855 | VSPI | SCLK/MISO/CS | MAX31855はMISO中心。CSは任意GPIOで定義する |
| ヒーター駆動 | SSR (NO) | GPIO | GPIO4 | 論理極性は設定可能とする |
| 運転許可スイッチ | スライドスイッチ | GPIO + pull-up | GPIO2 | pull-up前提。ON/OFF論理は設定可能とする |

### 4.2 安全側動作（電源投入/リセット）
- 起動直後はSSRを必ずOFFとする（初期化完了までONにならない）。
- スイッチが運転禁止状態の場合、SSRは常にOFFとする。
- センサ異常、過温度、内部エラー時はSSRを即時OFFとする。

---

## 5. 機能要件

### 5.1 温度計測（MAX31855）
- 熱電対温度（℃）を周期的に取得する。
- MAX31855のフォルト状態（断線等）を取得できること。
- 計測周期は制御に十分な頻度とする（推奨: 5〜10Hz程度）。
- 温度値の平滑化（移動平均等）を任意で適用できること（設定でON/OFF・窓幅変更可能）。

#### 異常時
- フォルト検出時はSSRをOFFにし、状態を`ERROR`へ遷移する。
- エラー内容（種別、発生時刻、直近温度等）をステータスAPIで参照可能とする。

---

### 5.2 温度プロファイル（案A: ポイント列）
#### 5.2.1 形式（JSON）
- 温度プロファイルは「時刻（秒）と目標温度（℃）の点列」で表現する。
- 点列間は線形補間し、任意時刻の目標温度 `Tset(t)` を得る。
- 最終点到達後の挙動は `end_behavior` で定義する。

例:
```json
{
  "name": "profile1",
  "version": 1,
  "points": [
    { "t_sec": 0,   "temp_c": 25  },
    { "t_sec": 60,  "temp_c": 120 },
    { "t_sec": 180, "temp_c": 150 },
    { "t_sec": 240, "temp_c": 80  }
  ],
  "end_behavior": "hold_last"
}
````

#### 5.2.2 バリデーション

* `points` は以下を満たすこと

  * `t_sec` は 0以上の整数
  * `t_sec` は単調増加（同値不可）
  * `temp_c` は許容範囲内（範囲は設定値で定義）
  * 点数は 2点以上
* 総運転時間 `max_duration_sec` を超えるプロファイルは拒否する（上限は設定値）。
* 不正なプロファイルは保存・運転開始を行わない。

#### 5.2.3 管理

* プロファイルの作成・更新・削除・一覧取得をAPIで提供する。
* プロファイルはFlashへ永続化し、再起動後も保持する。

---

### 5.3 制御（P制御 + 時間比例SSR）

#### 5.3.1 制御目標

* 実行中はプロファイルに従い `Tset(t)` を生成し、測定温度 `Tmeas` が追従するようにSSR出力を制御する。

#### 5.3.2 制御則（P制御）

* 誤差: `e = Tset - Tmeas`
* 操作量（0.0〜1.0のデューティ）:

  * `u = clamp(Kp * e + bias, 0, 1)`
* `Kp` と `bias` は設定値として変更可能とする。

#### 5.3.3 SSR駆動（時間比例制御）

* SSRはON/OFFのみのため、固定ウィンドウ長 `window_ms` を用いて時間比例制御を行う。

  * ウィンドウ内ON時間: `Ton = u * window_ms`
  * `Ton > 0` の期間はSSR ON、それ以外はSSR OFF
* `window_ms` は設定値として変更可能とする（推奨デフォルト: 1000ms）。
* チャタリング抑制のため `min_on_ms` / `min_off_ms` を設定できること（任意、推奨）。

#### 5.3.4 制御周期・タスク優先

* 制御演算周期は設定可能とし、Web処理等で著しく遅延しないこと（推奨: 100〜200ms）。
* 制御とWeb処理は分離し、制御が優先される構成とする。

---

### 5.4 運転許可スイッチ（GPIO2, pull-up）

* GPIO2は内部pull-upで入力する。
* スイッチにより「運転許可 / 運転禁止」を切り替える。
* スイッチ論理（ONがHIGH/LOW）は設定値で切り替え可能とする（配線差異吸収）。
* 運転禁止時の要件:

  * SSRは常にOFF
  * `RUNNING`状態であっても即時停止（`IDLE`または`DISABLED`へ遷移）
  * 運転禁止解除後、自動再開は行わない（ユーザーが再度開始操作を行う）

---

### 5.5 Webサーバー（UI配信）

* ESP32上でHTTPサーバーを動作させ、Wi-Fi経由でHTML/CSS/JSを配信する。
* ルート（`/`）アクセスでUIを表示する。
* 静的ファイルはFlash上に格納する（LittleFS推奨）。
* UIはフォーム操作によりREST APIを呼び出す。

#### UI最小要件（MVP）

* ステータス表示

  * 現在温度 `Tmeas`
  * 目標温度 `Tset`
  * 出力デューティ `u`
  * 状態（IDLE/RUNNING/ERROR等）
  * エラー内容
* プロファイル編集（案A）

  * 点列の追加/削除
  * `t_sec` と `temp_c` の入力
  * 保存/読込/削除
* 運転操作

  * 開始/停止

---

### 5.6 REST API（JSON）

#### 5.6.1 共通

* リクエスト/レスポンスはJSONとする。
* エラー時はHTTPステータスとエラーコードを返す。

推奨レスポンス例:

```json
{ "ok": true, "data": { ... } }
```

```json
{ "ok": false, "error": { "code": "PROFILE_INVALID", "message": "..." } }
```

#### 5.6.2 エンドポイント（最小）

* `GET /api/status`

  * 状態、Tmeas、Tset、u、経過時間、運転許可スイッチ状態、エラー情報、アクティブプロファイル名等
* `GET /api/profiles`

  * 保存済みプロファイル一覧
* `GET /api/profiles/{id}`

  * プロファイル取得
* `POST /api/profiles`

  * 新規作成
* `PUT /api/profiles/{id}`

  * 更新
* `DELETE /api/profiles/{id}`

  * 削除
* `POST /api/run`

  * 例: `{ "profile_id": "profile1" }`
* `POST /api/stop`
* `GET /api/config`
* `PUT /api/config`

  * 例: `Kp`, `bias`, `window_ms`, `Tmax`, 論理極性、平滑化設定、スイッチ論理 等

---

## 6. 状態管理要件

### 6.1 状態定義（例）

* `IDLE`: 待機（運転していない）
* `RUNNING`: プロファイル運転中
* `DISABLED`: 運転禁止（スイッチにより停止）
* `COMPLETED`: プロファイル完了（end_behaviorにより遷移）
* `ERROR`: 異常停止

### 6.2 遷移要件（代表）

* `IDLE` → `RUNNING`: `POST /api/run`（運転許可が有効、プロファイル有効）
* `RUNNING` → `IDLE`: `POST /api/stop`
* `RUNNING` → `DISABLED`: スイッチが運転禁止へ
* 任意 → `ERROR`: センサフォルト、過温度、内部異常
* `ERROR` からの復帰は「ユーザー操作 + 条件正常」を前提（例: `/api/stop`相当で解除、または再起動）

---

## 7. 安全・保護要件

### 7.1 過温度保護

* `Tmeas >= Tmax` の場合、SSRをOFFにし `ERROR` へ遷移する。
* `Tmax` は設定で変更可能、デフォルト値を持つ。

### 7.2 センサ異常

* MAX31855のフォルト検出時、SSRをOFFにし `ERROR` へ遷移する。

### 7.3 フェイルセーフ

* 例外・タスク停止・異常検知時は最終的にSSR OFFとなる設計とする。
* 起動時はSSR OFFを保証する。

---

## 8. 永続化要件

* 以下をFlashへ保存し、再起動後も保持する

  * プロファイル（案A JSON）
  * 設定（`Kp`, `bias`, `window_ms`, `Tmax`, 論理極性、平滑化、スイッチ論理 等）
  * （任意）Wi-Fi設定

---

## 9. 非機能要件

### 9.1 性能

* 制御ループがWebアクセス負荷で顕著に遅延しないこと。
* `GET /api/status` は短時間で応答する（推奨: 200ms以内）。

### 9.2 信頼性

* 設定・プロファイル破損時も起動不能とならない（バリデーション、デフォルト復旧）。
* 書き込み頻度はFlash寿命に配慮する（必要最小限の保存にする）。

### 9.3 セキュリティ（最小）

* LAN内利用を前提とする。
* （任意）簡易認証（固定トークン等）を設定で有効化できる構成とする。

### 9.4 可観測性

* シリアルログで状態遷移、エラー、主要計測値を出力できること。
* エラー情報はAPIで取得可能とする。

---

## 10. 受け入れ基準（テスト観点）

1. Web UIにアクセスでき、HTML/CSS/JSがESP32から配信される。
2. プロファイル（案A）を作成・保存・一覧・読込・削除できる。
3. `POST /api/run` で運転開始し、`POST /api/stop` で即時停止しSSR OFFとなる。
4. `GET /api/status` で `Tmeas/Tset/u/状態/エラー/スイッチ状態` が取得できる。
5. 熱電対断線等のフォルト発生時、SSR OFFとなり状態が `ERROR` になる。
6. `Tmax` 超過時、SSR OFFとなり状態が `ERROR` になる。
7. スイッチを運転禁止にすると、運転中でも即停止しSSR OFFとなる。解除後、自動再開しない。
8. 設定値（Kp等）を変更し、再起動後も保持される。

---

## 11. 実装指針（Codex向け補足）

* 推奨構成

  * センサ読取り、制御、Web/APIを分離（FreeRTOSタスクまたはタイマ駆動）
* SSR出力は「時間比例制御」を中心に実装する

  * `window_ms`単位でON/OFFを決定し、GPIO4を駆動
* 起動直後および異常時はSSR OFFを最優先とする
* プロファイルはJSONとして保存し、起動時に読み込み・検証する
* UIは`fetch()`でAPIを叩き、`/api/status`をポーリングして表示更新する（MVP）

---
